# Object Expression in Clojure

Обьектные выражения на Clojure:\
1 Часть - [Функциональные выражения](https://github.com/Nomad192-student-projects-ct-itmo/Functional-Expression-clj)\
2 Часть - Объектные выражения (текущая)

## Объектные выражения на Clojure

* Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` и `Negate` для представления арифметических выражений.
Пример описания выражения `2x-3`:
```clojure
(def expr
  (Subtract
    (Multiply
      (Constant 2)
      (Variable "x"))
    (Constant 3)))
```
                    
* Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением vars. Например, `(evaluate expr {"x" 2})` должно быть равно `1`.
* Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
* Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,
`(parseObject "(- (* 2 x) 3)")`
должно быть эквивалентно `expr`.
* Функция `(diff expression "variable")` должна возвращать выражение, представляющее производную исходного выражения по заданой перемененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Constant 2) (Constant 0))` и
```clojure
(Subtract
  (Add
    (Multiply (Constant 0) (Variable "x"))
    (Multiply (Constant 2) (Constant 1)))
  (Constant 0))
```
так же будут считаться правильным ответом.

---

### Сложный вариант. 

Конструкторы Add, Subtract, Multiply и Divide должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для +, -, *, /.

---

При выполнении задания можно использовать любой способ преставления объектов.

---

## Модификации
  * *ExpLn*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Exp` (`exp`) – экспонента, `(exp 8)` примерно равно 2981;
        * `Ln`  (`Ln`)  – натуральный логарифм абсолютной величины, `(ln 2981)` примерно равно 8.
 * *PowLog*. Дополнительно реализовать поддержку:
    * бинарных операций:
        * `Pow` (`pow`) – возведение в степень, `(pow 2 3)` равно 8;
        * `Log` (`log`) – логарифм абсолютной величины по основанию абсолютной величины, `(log -2 -8)` равно 3.
 * *MeanVarn*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Mean` (`mean`) – математическое ожидание аргументов, `(mean 1 2 6)` равно 3;
        * `Varn` (`varn`) – дисперсия аргументов, `(varn 2 5 11)` равно 14;
 * *SumexpSoftmax*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Sumexp` (`sumexp`) – сумма экспонент, `(sumexp 8 8 9)` примерно равно 14065;
        * `Softmax` (`Softmax`) – [softmax](https://ru.wikipedia.org/wiki/Softmax) первого аргумента, `(softmax 1 2 3)` примерно равно 0.09;
        
```diff
+ MeanVarn 
+ SumexpSoftmax 
+ PowLog 
+ ExpLn 
```
